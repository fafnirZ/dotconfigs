echo ".bashrc_extension loaded"
reload() {
	source ~/.bashrc
}
synctime() {
	sudo hwclock -s
}

gtcl() {
    if [ $# -lt 1 ]; then
        echo "Usage: gtcl <repo>"
        echo "options: -u|--user <user>"
        return 1
    fi
    while [[ $# -gt 1 ]]
    do
        case $1 in
            -u|--user)
            user=$2
            shift
            shift
            ;;
            *)
            shift
            ;;
        esac
    done
    if [ $user ]; then
        remote=$(echo $1 | sed "s/github\.com/github.com-$user/")
        git clone $remote
    else
        git clone $1
    fi
}


winpath_to_linuxpath() {
        arg=$1
        result=$(echo $arg| sed 's/\\/\//g' | sed 's|C:|/mnt/c|')                                                               
        echo $result
}

# fuzzy git branch
fzgb() {
	git branch | fzf | xargs git checkout
}

# fuzzy previous command history
fzcmd() {
	cat ~/.bash_history | fzf
}

# fuzzy copy contents of files searched recursively of current dir
fzcp() {
    fzf | xargs cat | clip.exe
}

# dora-explorer
cde() { 
	cd $(DORA_NOSELECT_FILE=1 de $@); 
}

#############
# diff tool #
#############
cdiff() {
    # args file1 file2
    local f1=$1
    local f2=$2
    if [ $# -lt 2 ]; then
        echo "usage: cdiff <file1> <file2>"
        return
    fi


    diff \
        --side-by-side \
        --suppress-common-lines \
        --color=always \
        $1 \
        $2 \
        | less -r
}

# autocompletion for this command
# has the _cd autocomplete
# from bash-complete
# check the function for _cd
# by running `type _cd`
complete -F _cd cdiff
#########################
# end diff tool section #
#########################

# aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF' 

# git utilities
alias gs='git status'
alias gb='git branch'
alias gl='git log'
alias gck='git checkout'
alias gpl='git pull'
alias gpsh='git push'

# neovim
nv() {
    nvim
}
complete -F _cd nv

# terraform
alias tf='terraform'
alias ansp='ansible-playbook'

clip() {
    os_name=$(uname -o)
    if [[ $os_name == 'Darwin' ]]; then 
        pbcopy
    elif [[ $os_name == "GNU/Linux" ]]; then
        # detect wsl
        contains_microsoft=$(uname -r | grep -qi 'microsoft' && echo 'True' || echo 'False')
        if [[ $contains_microsoft == 'True' ]]; then
            clip.exe
        else
            # normal linux
            xclip -selection clipboard
        fi
    else
        echo "not sure what you're running"
    fi
}

#########################################
# dynamically preview a file's contents
# using jq
#########################################

jqp() {
    # fzf spawns a non-login shell 
    # .bashrc is only sourced in a new interactive, non-login shell is started
    # which is why the custom `clip` command will not be found
    # which is why I store the clip_function's source code inside the variable
    # _load_clip then I run the code in the subshell such that it initialises the function
    # then afterwards I'm able to access the function within the subshell.
    _load_clip=$(which clip)

    file_path=$1
    cmd_="cat $file_path"
    echo '' |
        fzf \
        --preview "$cmd_ | jq {q}" \
        --preview-window up,1,100 \
        --bind 'enter:'\
        --bind "ctrl-y:execute($_load_clip && echo {q} | tr -d '\n' | clip)"
}